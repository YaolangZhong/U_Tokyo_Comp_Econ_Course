"""
Krusell-Smith Equilibrium Solver
================================
Main solver that iterates between:
1. Solving the household problem (given PLM)
2. Simulating the economy (given policy)
3. Updating the PLM (given simulation data)

The algorithm converges when the PLM coefficients stabilize,
meaning agents' beliefs about aggregate dynamics are consistent
with the actual aggregate dynamics generated by their behavior.
"""

import numpy as np

from config import (
    Pi, B_init, policy_init, k_ss,
    N_agents, T_sim, tol_B, max_iter_B
)
from shock import ShockSimulator
from household import solve_household_problem
from simulation import (
    simulate_economy, update_PLM_coefficients,
    compute_PLM_forecast, compute_forecast_errors
)


def solve_krusell_smith(
    B_init=B_init,
    policy_init=policy_init,
    max_iter=max_iter_B,
    tol=tol_B,
    verbose=True,
    seed=42
):
    """
    Solve for the Krusell-Smith equilibrium.
    
    Algorithm:
    1. Initialize PLM coefficients B
    2. Repeat until convergence:
       a. Solve household problem given B → policy function
       b. Simulate economy using policy → K time series
       c. Update B using OLS on simulated K series
    
    Parameters:
    -----------
    B_init : ndarray (2, 2) - Initial PLM coefficients
    policy_init : ndarray - Initial policy function guess
    max_iter : int - Maximum outer loop iterations
    tol : float - Convergence tolerance for B
    verbose : bool - Print progress
    seed : int - Random seed for simulation
    
    Returns:
    --------
    results : dict containing:
        - B: Final PLM coefficients
        - policy: Final policy function
        - consumption: Final consumption function
        - K_history: Aggregate capital time series
        - k_distribution: Final cross-sectional distribution
        - Z_history: Aggregate shock history
        - eps_history: Idiosyncratic shock history
        - R2: R-squared of PLM regressions
        - converged: Whether algorithm converged
    """
    if verbose:
        print("=" * 60)
        print("Krusell-Smith Algorithm")
        print("=" * 60)
    
    # Initialize
    B = B_init.copy()
    policy = policy_init.copy()
    
    # Generate shock sequences (fixed for all iterations)
    if verbose:
        print("\nGenerating shock sequences...")
    shock_sim = ShockSimulator(Pi)
    Z_history, eps_history = shock_sim.simulate(T_sim, N_agents, seed=seed)
    
    # Initial capital distribution
    k_init = np.ones(N_agents) * k_ss
    
    # Main loop
    converged = False
    for iteration in range(max_iter):
        if verbose:
            print(f"\n--- Outer Iteration {iteration + 1} ---")
        
        # Step 1: Solve household problem given current B
        if verbose:
            print("\nStep 1: Solving household problem...")
        policy, consumption, euler_error, hh_converged = solve_household_problem(
            policy, B, verbose=verbose
        )
        
        # Step 2: Simulate economy
        if verbose:
            print("\nStep 2: Simulating economy...")
        K_history, k_distribution = simulate_economy(
            policy, k_init, Z_history, eps_history
        )
        if verbose:
            print(f"  Mean K = {np.mean(K_history):.2f}, Std K = {np.std(K_history):.4f}")
        
        # Step 3: Update PLM coefficients
        if verbose:
            print("\nStep 3: Updating PLM coefficients...")
        B_new, B_diff, R2 = update_PLM_coefficients(B, K_history, Z_history, verbose=verbose)
        
        # Check convergence
        if B_diff < tol:
            converged = True
            if verbose:
                print(f"\n✓ Converged in {iteration + 1} iterations!")
            B = B_new
            break
        
        B = B_new
    
    if not converged and verbose:
        print(f"\n✗ Did not converge after {max_iter} iterations")
    
    # Final simulation with converged policy
    if verbose:
        print("\nFinal simulation...")
    K_history, k_distribution = simulate_economy(
        policy, k_init, Z_history, eps_history
    )
    
    # Compute PLM forecast for comparison
    K_plm = compute_PLM_forecast(B, K_history, Z_history)
    
    results = {
        'B': B,
        'policy': policy,
        'consumption': consumption,
        'K_history': K_history,
        'K_plm': K_plm,
        'k_distribution': k_distribution,
        'Z_history': Z_history,
        'eps_history': eps_history,
        'R2': R2,
        'euler_error': euler_error,
        'converged': converged
    }
    
    if verbose:
        print("\n" + "=" * 60)
        print("Results Summary")
        print("=" * 60)
        print(f"Converged: {converged}")
        print(f"PLM R² (bad):  {R2[0]:.6f}")
        print(f"PLM R² (good): {R2[1]:.6f}")
        print(f"Euler error:   {euler_error:.2e}")
        print(f"\nPLM Coefficients:")
        print(f"  Bad:  log(K') = {B[0,0]:.4f} + {B[0,1]:.4f} * log(K)")
        print(f"  Good: log(K') = {B[1,0]:.4f} + {B[1,1]:.4f} * log(K)")
    
    return results


def verify_approximate_aggregation(results, verbose=True):
    """
    Verify the approximate aggregation property.
    
    Krusell & Smith's key finding: the first moment (mean capital)
    is sufficient to forecast future aggregate capital with R² > 0.9999.
    
    Parameters:
    -----------
    results : dict - Output from solve_krusell_smith
    verbose : bool - Print results
    
    Returns:
    --------
    stats : dict with verification statistics
    """
    K_history = results['K_history']
    K_plm = results['K_plm']
    Z_history = results['Z_history']
    R2 = results['R2']
    
    from config import T_burn
    
    # Compute errors
    errors = compute_forecast_errors(K_history, K_plm, Z_history)
    
    # Overall forecast error
    K_actual = K_history[T_burn+1:]
    K_forecast = K_plm[T_burn+1:]
    max_pct_error = 100 * np.max(np.abs(K_actual - K_forecast) / K_actual)
    
    stats = {
        'R2_bad': R2[0],
        'R2_good': R2[1],
        'max_pct_error': max_pct_error,
        'errors_by_state': errors
    }
    
    if verbose:
        print("\n" + "=" * 60)
        print("Approximate Aggregation Verification")
        print("=" * 60)
        print(f"R² (bad state):  {R2[0]:.6f}")
        print(f"R² (good state): {R2[1]:.6f}")
        print(f"Max % forecast error: {max_pct_error:.4f}%")
        print("\nKrusell & Smith finding: R² > 0.9999")
        if R2[0] > 0.999 and R2[1] > 0.999:
            print("✓ Approximate aggregation holds!")
        else:
            print("✗ R² is lower than expected (may need more iterations)")
    
    return stats


if __name__ == "__main__":
    # Solve the model
    results = solve_krusell_smith(verbose=True)
    
    # Verify approximate aggregation
    stats = verify_approximate_aggregation(results, verbose=True)
    
    # Save results
    np.savez(
        'results/ks_results.npz',
        **{k: v for k, v in results.items() if isinstance(v, np.ndarray)}
    )
    print("\nResults saved to results/ks_results.npz")
